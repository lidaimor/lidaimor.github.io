<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemon</title>
  
  <subtitle>奋斗不息</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lidaimor/lidaimor.github.io/"/>
  <updated>2018-08-29T09:37:59.408Z</updated>
  <id>https://github.com/lidaimor/lidaimor.github.io/</id>
  
  <author>
    <name>Lemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS攻击+CSRF攻击</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/08/29/XSS%E6%94%BB%E5%87%BB-CSRF/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/08/29/XSS攻击-CSRF/</id>
    <published>2018-08-29T08:25:30.000Z</published>
    <updated>2018-08-29T09:37:59.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>1、 一旦在DOM解析过程成出现不在预期内的改变（JS代码执行或样式大量变化时），就可能发生XSS攻击<br>2、 XSS分为反射型XSS，存储型XSS和DOM XSS<br>3、 反射型XSS是在将XSS代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行。<br>4、 存储型XSS是将XSS代码存储到服务端（数据库、内存、文件系统等），在下次请求同一个页面时就不需要带上XSS代码了，而是从服务器读取。<br>5、 DOM XSS的发生主要是在JS中使用eval造成的，所以应当避免使用eval语句。<br>6、 XSS危害有盗取用户cookie，通过JS或CSS改变样式，DDos造成正常用户无法得到服务器响应。<br>7、 XSS代码的预防主要通过对数据解码，再过滤掉危险标签、属性和事件等。</p><h3 id="XSS危害"><a href="#XSS危害" class="headerlink" title="XSS危害"></a>XSS危害</h3><p>1、 通过document.cookie盗取cookie<br>2、 使用js或css破坏页面正常的结构与样式<br>3、 流量劫持（通过访问某段具有<code>window.location.href</code>定位到其他页面）<br>4、 Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。<br>5、 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。<br>6、 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</p><h3 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h3><blockquote><p>从以上的反射型和DOM XSS攻击可以看出，我们不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理。以上的代码出现的一些问题如下：<br>1、 没有过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。<br>2、 没有过滤危险的属性节点。如事件, <code>style, src, href</code>等<br>3、 没有对cookie设置httpOnly。</p></blockquote><h4 id="一-对cookie的保护"><a href="#一-对cookie的保护" class="headerlink" title="一.对cookie的保护"></a>一.对cookie的保护</h4><p>1、 对重要的cookie设置<code>httpOnly</code>, 防止客户端通过<code>document.cookie</code>读取cookie。服务端可以设置此字段。</p><h4 id="二-对用户输入数据的处理"><a href="#二-对用户输入数据的处理" class="headerlink" title="二.对用户输入数据的处理"></a>二.对用户输入数据的处理</h4><p>2、 编码：不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码。对于字符实体的概念可以参考文章底部给出的参考链接。<br>3、 解码：原样显示内容的时候必须解码，不然显示不到内容了。<br>4、 过滤：把输入的一些不合法的东西都过滤掉，从而保证安全性。如移除用户上传的DOM属性，如onerror，移除用户上传的Style节点，iframe, script节点等。</p><h2 id="CSRF攻击攻击原理及过程如下："><a href="#CSRF攻击攻击原理及过程如下：" class="headerlink" title="CSRF攻击攻击原理及过程如下："></a>CSRF攻击攻击原理及过程如下：</h2><blockquote><p>CSRF跨站点请求伪造<code>(Cross—Site Request Forgery)</code>，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p></blockquote><p>1、 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>2、 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；<br>3、 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>4、 网站B接收到用户请求后，返回攻击性代码，并发出一个请求要求访问第三方站点A；<br>5、 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p><blockquote><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</code>可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。<br>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：<br><code>src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory &quot;</code>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p></blockquote><h3 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h3><blockquote><p>目前防御 CSRF 攻击主要有三种策略：</p><ul><li>HTTP Referer 字段；</li><li>在请求地址中添加 token 并验证；</li><li>在 HTTP 头中自定义属性并验证。</li></ul></blockquote><h4 id="（1）在请求地址中添加-token-并验证"><a href="#（1）在请求地址中添加-token-并验证" class="headerlink" title="（1）在请求地址中添加 token 并验证"></a>（1）在请求地址中添加 token 并验证</h4><blockquote><p>在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p></blockquote><blockquote><p>通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p></blockquote><blockquote><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。</p></blockquote><blockquote><p>不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p></blockquote><h4 id="（2）在-HTTP-头中自定义属性并验证"><a href="#（2）在-HTTP-头中自定义属性并验证" class="headerlink" title="（2）在 HTTP 头中自定义属性并验证"></a>（2）在 HTTP 头中自定义属性并验证</h4><blockquote><p>这种方法也是使用 token 并进行验证，是把它放到 HTTP     头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p></blockquote><blockquote><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。</p></blockquote><blockquote><p>另外，对于没有进行CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h2&gt;&lt;p&gt;1、 一旦在DOM解析过程成出现不在预期内的改变（JS代码执行或样式大量变化时），就可能发生XSS攻击&lt;br&gt;2、 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向数据绑定原理</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/08/29/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/08/29/Vue双向数据绑定原理/</id>
    <published>2018-08-29T07:55:18.000Z</published>
    <updated>2018-08-29T09:34:06.024Z</updated>
    
    <content type="html"><![CDATA[<p>数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者</p><h3 id="1、实现Observer"><a href="#1、实现Observer" class="headerlink" title="1、实现Observer"></a>1、实现Observer</h3><blockquote><p>可以利用Obeject.defineProperty()来监听属性变动，<br>那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。</p></blockquote><blockquote><p>这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法</p></blockquote><blockquote><p>那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？<br>没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且<code>var dep = new Dep();</code>是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚</p></blockquote><h3 id="2、实现Compile"><a href="#2、实现Compile" class="headerlink" title="2、实现Compile"></a>2、实现Compile</h3><blockquote><p>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote><blockquote><p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中<br>compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定<br>这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如<code>&lt;span v-text=&quot;content&quot; other-attr</code>中 <code>v-text</code>便是指令，而<code>other-attr</code>不是指令，只是普通的属性。<br>监听数据、绑定更新函数的处理是在<code>compileUtil.bind()</code>这个方法中，通过<code>new Watcher()</code>添加回调来接收数据变化的通知</p></blockquote><h3 id="3、实现Watcher"><a href="#3、实现Watcher" class="headerlink" title="3、实现Watcher"></a>3、实现Watcher</h3><blockquote><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:<br>    1、自身实例化时往属性订阅器(dep)里面添加自己<br>    2、自身必须有一个update()方法<br>    3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。<br>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。<br>    4、实现MVVM<br>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。<br>一个简单的MVVM构造器是这样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MVVM</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.$options = options;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data;</span><br><span class="line">    </span><br><span class="line">observe(data, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.$compile = <span class="keyword">new</span> Compile(options.el || <span class="built_in">document</span>.body, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;br&gt;1、实现一个数据监听器Observer，能够对数据
      
    
    </summary>
    
      <category term="Vue" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的运行机制</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/08/29/JavaScript%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/08/29/JavaScript的运行机制/</id>
    <published>2018-08-28T18:25:02.000Z</published>
    <updated>2018-08-29T07:54:35.910Z</updated>
    
    <content type="html"><![CDATA[<ul><li>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</li><li>浏览器是多线程的，js是单线程的</li><li>相比于单进程浏览器，多进程有如下优点：<ol><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<h3 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h3><blockquote><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。<br>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p></blockquote><h3 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h3></li></ol></li></ul><ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li><li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ol><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li><li>最后Render进程将结果传递给Browser进程</li></ol></li><li>Browser进程接收到结果并将结果绘制出来<h3 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h3></li></ul><ul><li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享<blockquote><p>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</p></blockquote></li><li>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用<blockquote><p>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。<br>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</p></blockquote><h3 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h3>css是由单独的下载线程异步下载的。<h5 id="然后再说下几个现象："><a href="#然后再说下几个现象：" class="headerlink" title="然后再说下几个现象："></a>然后再说下几个现象：</h5><blockquote><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）<br>这可能也是浏览器的一种优化机制。<br>因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p></blockquote><h3 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h3>将该元素变成一个复合图层，就是传说中的硬件加速技术<br>最常用的方式：translate3d、translateZ<br>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）<br>will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），<br>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）<br><video><iframe><canvas><webgl>等元素<br>其它，譬如以前的flash插件<h3 id="absolute和硬件加速的区别"><a href="#absolute和硬件加速的区别" class="headerlink" title="absolute和硬件加速的区别"></a>absolute和硬件加速的区别</h3><blockquote><p>absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。<br>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）<br>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层<br>（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p></blockquote><h3 id="复合图层的作用？"><a href="#复合图层的作用？" class="headerlink" title="复合图层的作用？"></a>复合图层的作用？</h3>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡<br>硬件加速时请使用index<br>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染<blockquote><p>具体的原理时这样的：<br><strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</strong><br>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</p></blockquote></webgl></canvas></iframe></video></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;浏览器输入url，浏览器主进程接管，开一个下载线程，&lt;br&gt;然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，&lt;br&gt;随后将内容通过RendererHost接口转交给Renderer进程&lt;/li&gt;
&lt;li&gt;浏览器是多线程的，js
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/JavaScript/"/>
    
      <category term="进程" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>渐进增强和优雅降级</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/08/29/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/08/29/渐进增强和优雅降级/</id>
    <published>2018-08-28T17:44:58.000Z</published>
    <updated>2018-08-28T17:54:54.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="渐进增强（progressive-enhancement）"><a href="#渐进增强（progressive-enhancement）" class="headerlink" title="渐进增强（progressive enhancement）"></a>渐进增强（progressive enhancement）</h3><blockquote><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）</p></blockquote><h3 id="优雅降级（graceful-degradation）"><a href="#优雅降级（graceful-degradation）" class="headerlink" title="优雅降级（graceful degradation）"></a>优雅降级（graceful degradation）</h3><blockquote><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）<br>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。</p></blockquote><ul><li><p>渐进增强观点：</p><blockquote><p>渐进增强观点认为应该关注于内容本身。内容是我们建立网站的诱因，有的网站展示它，有的则收集它，有的寻求、有的操作，还有的网站甚至包含以上的种种，但相同点是他们全都涉及到内容，这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被Yahoo!所采纳并用以构建其“分级式浏览器支持（Graded Browser Support)“策略的原因所在。</p></blockquote></li><li><p>优雅降级观点：</p><blockquote><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如IE、Mozilla等）的前一个版本。<br>在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨（poor,but passable)”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;渐进增强（progressive-enhancement）&quot;&gt;&lt;a href=&quot;#渐进增强（progressive-enhancement）&quot; class=&quot;headerlink&quot; title=&quot;渐进增强（progressive enhancement）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/08/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/08/29/深拷贝和浅拷贝/</id>
    <published>2018-08-28T17:10:05.000Z</published>
    <updated>2018-08-28T17:37:34.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><ul><li>浅拷贝：假设B复制了A，当修改A时，如果B也跟着变了，说明这是浅拷贝</li><li>深拷贝：如果B不发生改变，说明这是浅拷贝</li><li>基本类型–名值存储在栈内存中</li><li>引用数据类型–名存在栈内存中，值存在于堆内存中<blockquote><p>深拷贝的三种方法：<br>深拷贝，是拷贝对象各个层级的属性</p></blockquote><h5 id="（1）递归"><a href="#（1）递归" class="headerlink" title="（1）递归"></a>（1）递归</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span>(obj[key]&amp;&amp;<span class="keyword">typeof</span> obj[key] ===<span class="string">"object"</span>)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>concat方法与slice也存在这样的情况，他们都不是真正的深拷贝</p></blockquote><h5 id="（2）借用JSON对象的parse和stringify"><a href="#（2）借用JSON对象的parse和stringify" class="headerlink" title="（2）借用JSON对象的parse和stringify"></a>（2）借用JSON对象的parse和stringify</h5><blockquote><p>JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储。</p></blockquote><h5 id="（3）借用JQ的extend方法。"><a href="#（3）借用JQ的extend方法。" class="headerlink" title="（3）借用JQ的extend方法。"></a>（3）借用JQ的extend方法。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.extend( [deep ], target, object1 [, objectN ] )</span><br><span class="line">deep表示是否深拷贝，为<span class="literal">true</span>为深拷贝，为<span class="literal">false</span>，则为浅拷贝</span><br><span class="line">target <span class="built_in">Object</span>类型 目标对象，其他对象的成员属性将被附加到该对象上。</span><br><span class="line">object1  objectN可选。 <span class="built_in">Object</span>类型 第一个以及第N个被合并的对象。</span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    </span><br><span class="line">b=$.extend(<span class="literal">true</span>,[],a);</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><blockquote><p>例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浅拷贝和深拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝和深拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝和深拷贝&quot;&gt;&lt;/a&gt;浅拷贝和深拷贝&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：假设B复制了A，当修改A时，如果B也跟着变了，说明这是浅拷贝&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的渲染过程</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/07/28/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/07/28/js常见问题总结/</id>
    <published>2018-07-28T03:58:12.000Z</published>
    <updated>2018-07-28T03:53:42.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="渲染引擎："><a href="#渲染引擎：" class="headerlink" title="渲染引擎："></a>渲染引擎：</h3><pre><code>Firefox使用Geoko  ——Mozilla自主研发的渲染引擎Safari和Chrome都使用webkit ——Webkit是一款开源渲染引擎</code></pre><h3 id="浏览器的渲染过程主要包括以下几步："><a href="#浏览器的渲染过程主要包括以下几步：" class="headerlink" title="浏览器的渲染过程主要包括以下几步："></a>浏览器的渲染过程主要包括以下几步：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML生成DOM树。</span><br><span class="line">2. 解析CSS生成CSSOM规则树。</span><br><span class="line">3. 将DOM树与CSSOM规则树合并在一起生成渲染树。</span><br><span class="line">4. 遍历渲染树开始布局，计算每个节点的位置大小信息。</span><br><span class="line">5. 将渲染树每个节点绘制到屏幕。</span><br></pre></td></tr></table></figure><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><pre><code>当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。构建CSSOM规则树浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。</code></pre><h4 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当浏览器遇到一个script标记时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。</span><br><span class="line">每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，</span><br><span class="line">而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的</span><br><span class="line">下载和构建。</span><br><span class="line">所以，script 标签的位置很重要。</span><br></pre></td></tr></table></figure><h5 id="实际使用时，可以遵循下面两个原则："><a href="#实际使用时，可以遵循下面两个原则：" class="headerlink" title="实际使用时，可以遵循下面两个原则："></a>实际使用时，可以遵循下面两个原则：</h5><pre><code>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。</code></pre><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个</span><br><span class="line">可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。</span><br></pre></td></tr></table></figure><h3 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制</span><br><span class="line">工作是由浏览器的UI后端组件完成的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">replaint（重绘）：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但</span><br><span class="line">元素的几何尺寸和位置不变。</span><br><span class="line">reflow（回流）： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染</span><br><span class="line">树的一部分或全部发生了变化。这就是Reflow，或是Layout。</span><br><span class="line"></span><br><span class="line">有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint一次，</span><br><span class="line">而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow或增量异步 reflow。</span><br><span class="line">有些情况下，比如 resize窗口，改变了页面默认的字体等。</span><br><span class="line">对于这些操作，浏览器会马上进行 reflow。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;渲染引擎：&quot;&gt;&lt;a href=&quot;#渲染引擎：&quot; class=&quot;headerlink&quot; title=&quot;渲染引擎：&quot;&gt;&lt;/a&gt;渲染引擎：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Firefox使用Geoko  ——Mozilla自主研发的渲染引擎
Safari和Chrome都使
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/06/14/Canvas/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/06/14/Canvas/</id>
    <published>2018-06-14T08:11:42.000Z</published>
    <updated>2018-06-14T08:16:40.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绘制环境"><a href="#绘制环境" class="headerlink" title="绘制环境"></a>绘制环境</h2><pre><code>getContext(&apos;2d&apos;)：目前只支持2d场景不能在样式里设置宽高，否则变成等比缩放（包括里面画的内容也会等比缩放）</code></pre><h2 id="绘制图形："><a href="#绘制图形：" class="headerlink" title="绘制图形："></a>绘制图形：</h2><ol><li><p>绘制方块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fillRect(L,T,W,H);  填充的方块</span><br><span class="line">strokeRect(L,T,W,H); 带边框的方块</span><br></pre></td></tr></table></figure></li><li><p>设置绘图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fillStyle：填充颜色（绘制canvas是有顺序的）</span><br><span class="line">lineWidth：线宽度，是一个数值</span><br><span class="line">strokeStyle：边线颜色</span><br></pre></td></tr></table></figure></li><li><p>绘制路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">beginPath：开始绘制路径（防止后面设置影响上面绘图）</span><br><span class="line">closePath：结束绘制路径（闭合绘图）</span><br><span class="line">moveTo：移动到绘制的新目标点</span><br><span class="line">lineTo：新的目标点</span><br><span class="line">stroke：画线，默认黑色</span><br><span class="line">fill：填充，默认黑色</span><br><span class="line">rect：矩形区域（与fill组成fillRect方法）</span><br><span class="line">clearRect：删除一个画布的矩形区域</span><br><span class="line">save：保存路径（与restore一起组成一个设置区）</span><br><span class="line">restore：恢复路径</span><br></pre></td></tr></table></figure></li><li><p>绘制圆（圆弧）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arc(x,y,半径,起始弧度,结束弧度,旋转方向)</span><br><span class="line">x,y：起始圆心坐标</span><br><span class="line">起始位置在<span class="number">3</span>点钟位置</span><br><span class="line">弧度与角度的关系：弧度=角度*<span class="built_in">Math</span>.pi/<span class="number">180</span></span><br><span class="line">旋转方向：顺时针（默认：<span class="literal">false</span>）、逆时针（<span class="literal">true</span>）</span><br></pre></td></tr></table></figure></li><li><p>变换（与css3中的变化类似）：变换的是画布</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">translate（偏移）：从起始点为基准点，移动当前坐标位置</span><br><span class="line"> rotate（旋转）：参数为弧度（默认的旋转中心是左上角）</span><br><span class="line"> scale（缩放）：x，y方向缩放到原本大小的倍数</span><br></pre></td></tr></table></figure></li></ol><h3 id="用Canvas做时钟的原理："><a href="#用Canvas做时钟的原理：" class="headerlink" title="用Canvas做时钟的原理："></a>用Canvas做时钟的原理：</h3><ol><li>首先绘制小刻度，是由60个6度的圆弧拼成，类似于马车轮,半径为r</li><li>在同样的圆心位置绘制白色表盘，盖住圆弧中间的线，半径为r*19/20</li><li>跟步骤1类似，绘制12个角度为30度的圆弧，长度为r</li><li>跟步骤2类似，,绘制白色表盘，半径为r*18/20</li><li>绘制时针分针秒针，获取时间对象</li><li>计时器调用以上步骤<h3 id="Canvas特点："><a href="#Canvas特点：" class="headerlink" title="Canvas特点："></a>Canvas特点：</h3></li><li>Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制</li><li>Canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li><li>快速、轻量、灵活</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;绘制环境&quot;&gt;&lt;a href=&quot;#绘制环境&quot; class=&quot;headerlink&quot; title=&quot;绘制环境&quot;&gt;&lt;/a&gt;绘制环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;getContext(&amp;apos;2d&amp;apos;)：目前只支持2d场景
不能在样式里设置宽高，否则变成等比
      
    
    </summary>
    
      <category term="HTML5" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/HTML5/"/>
    
    
      <category term="html5" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/html5/"/>
    
      <category term="js" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSS水平垂直居中</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/04/21/CSS%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/04/21/CSS水平垂直居中/</id>
    <published>2018-04-21T05:28:11.000Z</published>
    <updated>2018-04-21T06:19:19.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="1-内联元素和文字"><a href="#1-内联元素和文字" class="headerlink" title="1.内联元素和文字"></a>1.内联元素和文字</h3><pre><code>&lt;div&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><ol><li><p><code>div{text-align:center}</code> 加在父元素上</p></li><li><p>把内联元素设置为block</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-块级元素"><a href="#2-块级元素" class="headerlink" title="2.块级元素"></a>2.块级元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1 father"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2 son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">width</span>: <span class="number">500px</span>;<span class="attribute">background-color</span>: yellow;<span class="attribute">height</span>: <span class="number">300px</span>;&#125;</span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: pink;<span class="attribute">height</span>: <span class="number">100px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="（1）子元素宽度已知"><a href="#（1）子元素宽度已知" class="headerlink" title="（1）子元素宽度已知"></a>（1）子元素宽度已知</h4><ol><li>定位，适用于子元素比父元素宽的情况</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>div2必须设置宽度,不适用于子元素比父元素宽的情况</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）子元素宽度未知"><a href="#（2）子元素宽度未知" class="headerlink" title="（2）子元素宽度未知"></a>（2）子元素宽度未知</h4><ol><li>不支持ie6,ie7</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用absolute + transform</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>; </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用flex + margin，ie6,ie7,ie8不支持</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;<span class="attribute">display</span>: flex;&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用flex + justify-center, ie6,ie7,ie8不支持</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; </span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="1-内联元素和文字-1"><a href="#1-内联元素和文字-1" class="headerlink" title="1.内联元素和文字"></a>1.内联元素和文字</h3><p><code>line-height=行高;</code></p><h3 id="2-块级元素-1"><a href="#2-块级元素-1" class="headerlink" title="2.块级元素"></a>2.块级元素</h3><p>（1）子元素高度已知</p><ol><li>定位</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123; </span><br><span class="line">    <span class="attribute">position</span>: relative; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>; </span><br><span class="line">    <span class="attribute">margin-top</span>:-<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）子元素高度未知</p><ol><li>table-cell + vertical-align , 只需加在父元素上</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用absolute + transform</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123; </span><br><span class="line">    <span class="attribute">position</span>: relative; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123; </span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>; </span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-50%); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; title=&quot;水平居中&quot;&gt;&lt;/a&gt;水平居中&lt;/h2&gt;&lt;h3 id=&quot;1-内联元素和文字&quot;&gt;&lt;a href=&quot;#1-内联元素和文字&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>html+css常见问题总结</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/04/16/html-css%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/04/16/html-css常见问题总结/</id>
    <published>2018-04-16T09:26:14.000Z</published>
    <updated>2018-04-21T05:27:05.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-块元素和内联元素的区别"><a href="#1-块元素和内联元素的区别" class="headerlink" title="1.块元素和内联元素的区别"></a>1.块元素和内联元素的区别</h2><p><strong>区块元素</strong>：每个元素独占一行；支持所有的样式；不设置宽度时宽度等于父元素宽度；换行符不会解析；<br><strong>内联元素</strong>：在一行有空间时，多个元素可以在同一行显示；不支持宽高样式，使用上下margin和padding等样式会出现问题；宽度由内容（文字图片等）撑开；换行符会被解析（不同浏览器下显示的宽度也不同）<br><i>注：p元素下不可嵌套任何区块元素，放区块元素，内容会被截断。</i></p><h2 id="2-替换元素和不可替换元素"><a href="#2-替换元素和不可替换元素" class="headerlink" title="2.替换元素和不可替换元素"></a>2.替换元素和不可替换元素</h2><h5 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h5><p>浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p><p>例如浏览器会根据<code>&lt;img&gt;</code>标签的src属性的值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；又例如根据<code>&lt;input&gt;</code>标签的type属性来决定是显示输入框，还是单选按钮等。 html中的<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code>都是替换元素。这些元素往往没有实际的内容，即是一个空元素，例如： <code>&lt;img src=”cat.jpg” /&gt;`</code><input type="submit" name="submit" value="提交">` 浏览器会根据元素的标签类型和属性来显示这些元素。<br>可替换元素也在其显示中生成了框。 </p><h5 id="不可替换元素"><a href="#不可替换元素" class="headerlink" title="不可替换元素"></a>不可替换元素</h5><p> html 的大多数元素是不可替换元素，即其内容直接表现给用户端（例如浏览器）。</p><p>例如： <code>&lt;p&gt;</code>段落的内容<code>&lt;/p&gt;</code>段落<code>&lt;p&gt;</code>是一个不可替换元素，文字“段落的内容”全被显示。</p><h2 id="3-盒子模型有几种？区别是什么？"><a href="#3-盒子模型有几种？区别是什么？" class="headerlink" title="3.盒子模型有几种？区别是什么？"></a>3.盒子模型有几种？区别是什么？</h2><p>盒模型有border-box,content-box(默认),padding-box;<br>（1）border-box：设置的宽高为整个盒子除了margin之外的大小<br>（2）content-box：设置的宽高为内容部分<br>（3）padding-box: width 和 height 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 5.0中被删除。</p><h2 id="4-CSS选择器的优先级"><a href="#4-CSS选择器的优先级" class="headerlink" title="4.CSS选择器的优先级"></a>4.CSS选择器的优先级</h2><p>id选择器&gt;class选择器=伪类选择器&gt;标签名选择器</p><h2 id="5-隐藏元素的方法有哪些？"><a href="#5-隐藏元素的方法有哪些？" class="headerlink" title="5.隐藏元素的方法有哪些？"></a>5.隐藏元素的方法有哪些？</h2><p>（1）display:none;<br>（2）visibility:hidden;<br>（3）opacity 设为 0;<br>（4）position 设为 absolute 然后将位置设到不可见区域<br>（5）Clip-path 该属性很少见，该属性是通过裁剪的方法实现隐藏的。被隐藏的内容依然占据着那个位置，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。此外，这个属性能够使用各种过渡动画来实现不同的效果。<br>在IE中是完全不支持的</p><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p><1>display:none 在隐藏元素时，将其占位空间也去掉，子元素也会一同从盒子模型中消失。jq中的show(),hide(),toggle()方法就是通过改变display的值来实现变化效果的。</1></p><p><2>visibility:hidden 类似opacity属性，只是隐藏了内容，而其占位空间仍然保留，与 opacity 唯一不同的是它不会响应任何用户交互，元素在读屏软件中也会被隐藏。<br>如果一个元素的 visibility 被设置为 hidden，但是想要显示它的子元素，只要给想要显示的子元素添加visibility：visible;</2></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-块元素和内联元素的区别&quot;&gt;&lt;a href=&quot;#1-块元素和内联元素的区别&quot; class=&quot;headerlink&quot; title=&quot;1.块元素和内联元素的区别&quot;&gt;&lt;/a&gt;1.块元素和内联元素的区别&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;区块元素&lt;/strong&gt;：每个元素
      
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/CSS/"/>
    
    
      <category term="css" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/css/"/>
    
      <category term="html" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js中DOM的属性和操作</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/04/13/Js%E7%9A%84DOM%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/04/13/Js的DOM相关操作/</id>
    <published>2018-04-13T07:38:48.000Z</published>
    <updated>2018-04-14T02:21:24.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元素的属性：obj-XXX-没有括号"><a href="#元素的属性：obj-XXX-没有括号" class="headerlink" title="元素的属性：obj.XXX ,没有括号"></a>元素的属性：obj.XXX ,没有括号</h3><p><code>1.obj.childNodes</code><br>只读属性—子节点列表集合<br><code>2.obj.nodeType</code><br>只读属性—获取元素的节点类型，1元素节点，2属性节点，3文本节点。<br>3.<code>obj.attributes</code><br>只读属性—元素的属性<br>4.<code>obj.children</code><br>只读属性—元素节点的列表集合<br>5.<code>obj.firstChild</code><br>只读属性—第一个子节点<br><code>var oFirst = obj.firstElementChild || obj.firstChild;</code></p><p>6.<code>obj.lastChild</code><br>只读属性—最后一个子节点<br><code>var oLast = obj.lastElementChild || obj.lastChild;</code></p><p>7.<code>obj.nextSibling</code><br>只读属性—下一个兄弟节点<br><code>var oNext = obj.nextElementSibling || obj.nextSibling;</code></p><p>8.<code>obj.previousSibling</code><br>只读属性—上个兄弟节点<br><code>var oPrev = obj.previousElementSibling || obj.previousSibling;</code></p><p>9.<code>obj.parentNode</code><br>只读属性–父节点：由于父元素是唯一的，因此没有兼容问题<br>10.<code>obj.offsetParent</code><br>只读属性—距当前元素最近一个有定位属性的父元素节点：若无定位父级则默认会找到body（若<br>在ie7及以下的浏览器中，该元素在没有定位的时候找的是body，有定位的时候则变成html）<br>11.<code>obj.offsetLeft/offsetTop</code><br>只读属性—当前元素到其定位父级的距离（偏移值）：<br>若有定位的父级，但自己没有定位，在ie7及以下浏览器里该属性指的是到body的距离，<br>其他浏览器中则是到定位父级的距离；<br>若无定位父级，ie8及以下浏览器是到html的距离<br>12.<code>obj.offsetWidth/offsetHeight</code><br>只读属性–当前元素的占位宽高<br><code>obj.style.width</code>的取值可以得到元素属性<code>style</code>里的宽度（行间样式）<br><code>obj.clientWidth</code>的值为<code>style.width+padding</code>（盒子宽度去掉边框border的部分）<br><code>obj.offsetWidth</code>（占位宽）既盒子宽度（margin不属于盒子内部）<br>13.<code>obj.offsetLeft</code> 和 <code>obj.offsetTop</code> 会获取该元素到其定位父级的距离</p><h3 id="DOM元素的操作"><a href="#DOM元素的操作" class="headerlink" title="DOM元素的操作"></a>DOM元素的操作</h3><blockquote><p>1.向父元素动态创建元素</p></blockquote><pre><code>var oLi=document.createElement(&quot;li&quot;);oUl.appendChild(oLi);    //在父级最后节点后添加该元素oUl.insertBefore(oLi,b) //在父级b节点前添加该元素oUl.children[0] ? oUl.insertBefore(oLi,oUl.children[0]) : oUl.appendChild(oLi)</code></pre><blockquote><p>2.父级.removeChild(li);    //从父级中删除某子节点</p></blockquote><blockquote><p>3.父级.replaceChild(新节点,被替换节点) //在父元素中用新节点替换某子节点</p></blockquote><p>注：<code>appendChild</code>,<code>insertBefore</code>,<code>replaceChild</code>等方法都可以操作动态创建的元素，也可以操作已有的节<br>点，它们都是剪切操作</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1.最多生成5条留言，超过会删除最早生成的留言，点击背景颜色变黄，点击删除删除背景为黄色的留言<br><a href="https://github.com/lidaimor/JavaScript/tree/master/js---%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80">https://github.com/lidaimor/JavaScript/tree/master/js---%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80</a><br>2.五个多选框，最对选3个<br><a href="https://github.com/lidaimor/JavaScript/tree/master/js---%E4%BA%94%E4%B8%AA%E5%A4%9A%E9%80%89%E6%A1%86%E6%9C%80%E5%A4%9A%E9%80%89%E4%B8%89%E4%B8%AA">https://github.com/lidaimor/JavaScript/tree/master/js---%E4%BA%94%E4%B8%AA%E5%A4%9A%E9%80%89%E6%A1%86%E6%9C%80%E5%A4%9A%E9%80%89%E4%B8%89%E4%B8%AA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;元素的属性：obj-XXX-没有括号&quot;&gt;&lt;a href=&quot;#元素的属性：obj-XXX-没有括号&quot; class=&quot;headerlink&quot; title=&quot;元素的属性：obj.XXX ,没有括号&quot;&gt;&lt;/a&gt;元素的属性：obj.XXX ,没有括号&lt;/h3&gt;&lt;p&gt;&lt;cod
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>浮动和清除</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/03/28/css/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/03/28/css/</id>
    <published>2018-03-28T09:46:47.000Z</published>
    <updated>2018-03-29T13:38:23.711Z</updated>
    
    <content type="html"><![CDATA[<p>浮动（float）：使元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住。</p><blockquote><p>清除浮动：</p></blockquote><pre><code>1、给父元素设置高度2、overflow:hidden 溢出隐藏 3、添加伪类（.clearfix）   .clearfix:before,.clearfix:after{content:&quot;&quot;;display:block;}   .clearfix:after{clear:both}   .clearfix{*zoom:1;}</code></pre><blockquote><p>overflow:hidden清除浮动原理</p></blockquote><pre><code>BFC （Block Formatting Context）全称是块级格式化上下文，用于对块级元素排版，默认情况下只有根元素（body)一个块级上下文，但是如果一个块级元素 设置了float:left，overflow:hidden或position:absolute样式，就会为这个块级元素生成一个独立的块圾上下文，就像在window全局作用域内，声明了一个function就会生成 一个独立的作用域一样，新开僻的BFC像是开僻了一个新的小宇宙，使这个块圾元素内部的排版完全独立隔绝。独立的块级上下文可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，也就是说包含块会把浮动元素的高度也计算在内，所以不用清除浮动来撑起高度。</code></pre><p>可以利用浮动做三栏布局</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浮动（float）：使元素脱离文档流，按照浮动方向移动，遇到父级边界或者相邻浮动元素停住。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;清除浮动：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1、给父元素设置高度

2、overflow:hidden 溢出隐藏 

      
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/CSS/"/>
    
    
      <category term="css" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/css/"/>
    
      <category term="BFC" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客记录</title>
    <link href="https://github.com/lidaimor/lidaimor.github.io/2018/03/26/article-title/"/>
    <id>https://github.com/lidaimor/lidaimor.github.io/2018/03/26/article-title/</id>
    <published>2018-03-26T13:05:50.000Z</published>
    <updated>2018-03-29T13:38:27.835Z</updated>
    
    <content type="html"><![CDATA[<p>用了几天时间，我终于用hexo+GitHub成功搭建了博客，查找了很多教程，遇到了很多问题，都是上网查找解决<br>发现了几个有用并且讲的非常详细的教程，列举在下面：</p><blockquote><p>1.用Hexo+Github 搭建属于自己的博客<br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">https://blog.csdn.net/gdutxiaoxu/article/details/53576018</a><br>2.更换主题外观<br><a href="https://www.jianshu.com/p/469e985288b3?from=jiantop.com" target="_blank" rel="noopener">https://www.jianshu.com/p/469e985288b3?from=jiantop.com</a><br>3.主题个性化配置<br><a href="https://segmentfault.com/a/1190000009544924#articleHeader22" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009544924#articleHeader22</a>  </p></blockquote><blockquote><p>问题：<br>    1.搭建成功之后，每次访问都要在GitHub-&gt;lidaimor-&gt;setting里绑定域名<br>      原因：每次刷新都会覆盖CNAME文件<br>      解决方法：在source目录下新建一个CNAME文件，不加后缀，里面写域名（lixinzz.top），成功解决问题。<br>    2.中文出现乱码：重新保存一遍文件，编码格式改为UTF-8</p></blockquote><blockquote><p>上传博客：<br>      hexo clean<br>      hexo generate<br>      hexo deploy</p></blockquote><blockquote><p>上传Git：</p></blockquote><pre><code> 1、在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库； 2、把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库； 3、再通过git commit -m &quot;注释内容&quot;把项目提交到仓库； 4、在Github上设置好SSH密钥后，新建一个远程仓库，通过git remote add origin https://github.com/guyibang/TEST2.git将本地仓库和远程仓库进行关联； 5、最后通过git push -u origin master把本地仓库的项目推送到远程仓库上；</code></pre><p>最后，希望自己坚持更新博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了几天时间，我终于用hexo+GitHub成功搭建了博客，查找了很多教程，遇到了很多问题，都是上网查找解决&lt;br&gt;发现了几个有用并且讲的非常详细的教程，列举在下面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.用Hexo+Github 搭建属于自己的博客&lt;br&gt;&lt;a hr
      
    
    </summary>
    
      <category term="hexo" scheme="https://github.com/lidaimor/lidaimor.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/hexo/"/>
    
      <category term="Git" scheme="https://github.com/lidaimor/lidaimor.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
